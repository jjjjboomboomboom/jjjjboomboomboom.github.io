##最近在学习极客时间的MySQL实战45讲，记录一下学习内容：

### mysql的组件主要分为：连接器——查询缓存——分析器——优化器——执行器——存储引擎

连接器、分析器、优化器、执行器的功能跨多个存储引擎。


### 连接器：管理连接、权限认证
  1、通过show processlist命令可以看到已经建立的连接。
  2、wait_timeout参数控制连接空闲断开时间，默认为8小时。建议使用长连接，但执行过程中的临时内存是管理在连接对象里的，因此可能造成内存上涨。解决办法：
    a)定期断开长连接。通过程序判断执行过一个占用大内存的查询后，断开连接，后续查询时再重连。
    b)Mysql5.7+版本支持通过mysql_rest_connection参数来重新初始化连接资源。
### 查询缓存：不建议使用，因为更新操作会清空缓存，Mysql8.0已经将查询缓存功能删除。
### 分析器：词法分析、语法分析
  判断语法、表、列是否存在等。
### 优化器：执行计划生成，索引选择
### 执行器：操作引擎，返回结果
  慢查询日志中的rows_examined表示语句执行过程中**执行器**向**存储引擎**请求了多少次，而不是存储引擎扫描了多少行。



##两个日志对比：

|          | redo log                                                 | bin log                                                  |
| -------- | -------------------------------------------------------- | -------------------------------------------------------- |
| 位置   | InnoDB引擎特有，位于mysql的存储引擎层       | Server层实现，所有存储引擎都可以使用      |
| 记录内容 | 记录物理日志，即在某个数据页做了什么修改，真实的物理操作 | 记录逻辑日志，语句的原始逻辑，如给ID=2的这行数据的C列加1 |
| 写形式 | 固定的空间大小，循环写，满了就写入到磁盘中 | 追加写，不会覆盖，记录全量的备份数据   |


## 事务

### ACID：Atomicity原子性、Consistency一致性、Isolation隔离性、Durability持久性

### 脏读dirty read（读取了另一个未提交的事务中的数据）、不可重复读non-repeatable read（读取了前一事务提交的数据，多次读取结果不同）、幻读phantom read [举例](https://www.zhihu.com/question/47007926)

### 隔离级别：
#### read uncommitted读未提交：一个事务还没提交时，他做的变更就能被别的事务看到。
#### read committed读提交：一个事务提交后，它的变更才会被其他事务看到。
#### repeatable read可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的
#### serializable串行化：写会加锁，读会加锁。

例子：

![image](https://user-images.githubusercontent.com/32328586/117567002-7e242300-b0ec-11eb-9340-3b34995e633a.png)

- 若隔离级别是“读未提交”， 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。
- 若隔离级别是“读提交”，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。
- 若隔离级别是“可重复读”，则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。
- 若隔离级别是“串行化”，则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。

可重复读：数据库会通过MVCC机制创建一个视图，访问的时候以视图的逻辑结果为准，该级别的视图是在事务开始时创建的，整个事务都会使用这个视图。

Mysql的默认级别是RR，Oracle的级别是rc。

可以使用show variables like 'transaction_isolation';来查看当前的值。


### MVCC的实现：
在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。

![image](https://user-images.githubusercontent.com/32328586/117567765-3a331d00-b0f0-11eb-97a9-55dd7bb79aa1.png)

前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。

回滚日志在不需要的时候才删除。系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除，即当系统里没有比这个回滚日志更早的 read-view 的时候。
因此不建议使用长事务，因为在事务结束前，会保留大量的回滚日志。

可以在information_schema库的innodb_trx表中查询长事务：
``` markdown
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```



## 索引

二叉树的搜索效率是最高的，但实际大多数据库存储实现却不使用二叉树，因为索引不仅存在内存中，还要写到磁盘上。
二叉树的高度较高，访问树的一个节点=访问一次磁盘，一张100万数据的表，从磁盘读取一个数据块的时间大概为10ms，树高20，即一次查询需要10*20=200ms，很慢。（InnoDB通常使用1200叉树作为索引的数据结构）

### 主键索引和非主键索引

#### 主键索引
又称聚簇索引，叶子节点存的是整行数据

#### 非主键索引
又称二级索引，叶子节点存的是主键的值。


例子：一个主键列为 ID 的表，表中有字段 k，并且在 k 上有索引
``` markdown
mysql> create table T(
id int primary key, 
k int not null, 
name varchar(16),
index (k))engine=InnoDB;
```

R1~R5 的 (ID,k) 值分别为 (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)，两棵树的示例示意图如下。

![image](https://user-images.githubusercontent.com/32328586/117578885-29e86580-b123-11eb-9dde-be266328170f.png)



### 索引维护
如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。而更糟的情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。
页分裂也影响数据页的利用率，一个页数据分成两个页，对于原本的一页下降50%。当删除数据时，相邻两页利用率变很低后，也会自动合并页。

**自增主键的优势：每次插入数据，都是追加操作，不涉及挪动其他记录，也不触发叶子节点的页分裂**，而当uuid作为主键，不保证有序追加插入，这样写数据成本相对较高，因为有可能触发页分裂和挪其他记录。

由于每个**非主键索引**的叶子节点上都是主键的值，假如用uuid作为主键，每个二级索引的叶子节点占用约32个字节。而用整形做主键，只要4个字节，长整型是8个字节。

**显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小**

- ASCII 码中，一个英文字母（不分大小写）为一个字节，一个中文汉字为两个字节。
- UTF-8 编码中，一个英文字为一个字节，一个中文为三个字节。

适合用业务字段做主键的场景：
1、只有一个索引，即二级索引很少的时候或没有，这时就可以直接使用主键索引查询，不需要二级索引导致查询2次。
2、该索引是唯一索引


### 回表
回到主键索引树搜索的过程，称为回表。

避免回表的场景：**覆盖索引**
假如只需要查询主键，例如只查询id：select **ID** from T where k between 3 and 5;要查询的值已经在k索引树上了，不需要回表。

**由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。**

注意点：在引擎内部使用覆盖索引在索引 k 上其实读了三个记录，R3~R5（对应的索引 k 上的记录项），但是对于 MySQL 的 Server 层来说，它就是找引擎拿到了两条记录，因此 MySQL 认为扫描行数是 2，即rows_examined为2。


### 多列索引
需要考虑最左前缀匹配原则，索引的顺序取决于：
- 索引的使用频率，高频的放前面
- 索引占用的空间，空间大的索引尽量复用。
- 覆盖索引场景（当多列索引的列覆盖需要查询的列时，会触发覆盖索引，减少回表查询）


![image](https://user-images.githubusercontent.com/32328586/117581140-e5ae9280-b12d-11eb-8808-46edadcdd296.png)

（a,b）的联合索引，可以看到a的值是有顺序的，1，1，2，2，3，3，而b的值是没有顺序的1，2，1，4，1，2。但是我们又可发现a在等值的情况下，b值又是按顺序排列的，但是这种顺序是相对的。这是因为MySQL创建联合索引的规则是首先会对联合索引的最左边第一个字段排序，在第一个字段的排序基础上，然后在对第二个字段进行排序。所以b=2这种查询条件没有办法利用索引。


经典例子：
表结构如下：
``` markdown

CREATE TABLE `geek` (
  `a` int(11) NOT NULL,
  `b` int(11) NOT NULL,
  `c` int(11) NOT NULL,
  `d` int(11) NOT NULL,
  PRIMARY KEY (`a`,`b`),
  KEY `c` (`c`),
  KEY `ca` (`c`,`a`),
  KEY `cb` (`c`,`b`)
) ENGINE=InnoDB;
```

由于历史原因，这个表需要 a、b 做联合主键。既然主键包含了 a、b 这两个字段，那意味着单独在字段 c 上创建一个索引，就已经包含了三个字段了呀，为什么要创建“ca”“cb”这两个索引？
因为存在如下业务场景：
``` markdown
select * from geek where c=N order by a limit 1;
select * from geek where c=N order by b limit 1;
```

索引不合理，索引ca可以去掉，因为：

**InnoDB会把主键字段放到索引定义字段后面**，因为会回表进行查询，距离，当使用c索引，查询到了相关列的主键后，需要使用主键索引进行回表查询相关字段，因为主键索引本来就是根据a，b进行排序的，所以实际上就是c，a，b索引。
不显示是因为去重的原因。

所以，当主键是(a,b)的时候，
定义为c的索引，实际上是（c,a,b)，**因此c索引已经包含了ca索引了**;
定义为(c,a)的索引，实际上是(c,a,b)

ps 定义为(c,b）的索引，实际上是（c,b,a)



### 锁

- 全局锁
  - 主要用于全库逻辑备份，加全局读锁方法Flush tables with read lock（FTWRL），一致性读视图（single-transaction）可以代替FTWRL来进行备份，但前提是存储引擎需要支持事务，像MyISAM引擎，还是需要使用FTWRL。
    - 当主库上备份时，在备份期间不能执行更新，业务处于中断时间
    - 当从库上备份，那备份期间从库不能执行主库同步过来的binlog，会导致主从延迟。
  - 不建议使用set global readonly=true的方式，避免数据库异常断开导致数据库一直处于只读状态。第二点是，这个值可能会被用于判断其他逻辑，例如主库还是备库。
- 表级锁
  - 表锁 lock tables read/write
  - 元数据锁 MDL，不需要显示使用，在访问一个表的时候会自动加上；
    - 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。（由于隔离级别，读是读一个旧视图）
    - 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。（安全地给热表加字段：使用wait n/nowait语法，如alter table tbl_name nowait add column/alter tbl_name wait n add column）
    - 当你对一个表做DML（CURD）时，获取的是表读锁，当你对一个表做DDL（create、alter、drop）时，获取的是表写锁。

例子

![image](https://user-images.githubusercontent.com/32328586/117699625-a51b4b80-b1f7-11eb-8ad1-fea180495e1e.png)



### 行锁
MyIsam不支持行锁

DDL(create、alter、drop)，获取的是表写锁，也包括行写锁
DML（CURD）获取的是表读锁，CUD获取的是行写锁，R获取的是行读锁

> 在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。

例子：
![image](https://user-images.githubusercontent.com/32328586/127766227-e56fe216-7349-401e-a5d7-0d0a06ec8cd4.png)
实际上事务 B 的 update 语句会被阻塞，直到事务 A 执行 commit 之后，事务 B 才能继续执行。

- 实际应用规则：如果你的事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。

例子2：
```
假设你负责实现一个电影票在线交易业务，顾客 A 要在影院 B 购买电影票。我们简化一点，这个业务需要涉及到以下操作：
1、从顾客 A 账户余额中扣除电影票价；
2、给影院 B 的账户余额增加这张电影票价；
3、记录一条交易日志。也就是说，要完成这个交易，我们需要 update 两条记录，并 insert 一条记录。

当然，为了保证交易的原子性，我们要把这三个操作放在一个事务中。那么，你会怎样安排这三个语句在事务中的顺序呢？

试想如果同时有另外一个顾客 C 要在影院 B 买票，那么这两个事务冲突的部分就是语句 2 了。因为它们要更新同一个影院账户的余额，需要修改同一行数据。

根据两阶段锁协议，不论你怎样安排语句顺序，所有的操作需要的行锁都是在事务提交的时候才释放的。所以，如果你把语句 2 安排在最后，比如按照 3、1、2 这样的顺序，那么影院账户余额这一行的锁时间就最少。这就最大程度地减少了事务之间的锁等待，提升了并发度。
```

> 反思例子：例如cmdb修改实例的状态，需要在region视图和云服务视图中进行update操作，但考虑到云服务视图的使用比region视图要多，因此可以先对region视图进行操作（操作中会加行锁），然后再修改云服务视图中的实例记录。







