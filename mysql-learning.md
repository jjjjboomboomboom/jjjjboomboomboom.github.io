##最近在学习极客时间的MySQL实战45讲，记录一下学习内容：

### mysql的组件主要分为：连接器——查询缓存——分析器——优化器——执行器——存储引擎

连接器、分析器、优化器、执行器的功能跨多个存储引擎。


### 连接器：管理连接、权限认证
  1、通过show processlist命令可以看到已经建立的连接。
  2、wait_timeout参数控制连接空闲断开时间，默认为8小时。建议使用长连接，但执行过程中的临时内存是管理在连接对象里的，因此可能造成内存上涨。解决办法：
    a)定期断开长连接。通过程序判断执行过一个占用大内存的查询后，断开连接，后续查询时再重连。
    b)Mysql5.7+版本支持通过mysql_rest_connection参数来重新初始化连接资源。
### 查询缓存：不建议使用，因为更新操作会清空缓存，Mysql8.0已经将查询缓存功能删除。
### 分析器：词法分析、语法分析
  判断语法、表、列是否存在等。
### 优化器：执行计划生成，索引选择
### 执行器：操作引擎，返回结果
  慢查询日志中的rows_examined表示语句执行过程中**执行器**向**存储引擎**请求了多少次，而不是存储引擎扫描了多少行。



##两个日志对比：

|          | redo log                                                 | bin log                                                  |
| -------- | -------------------------------------------------------- | -------------------------------------------------------- |
| 位置   | InnoDB引擎特有，位于mysql的存储引擎层       | Server层实现，所有存储引擎都可以使用      |
| 记录内容 | 记录物理日志，即在某个数据页做了什么修改，真实的物理操作 | 记录逻辑日志，语句的原始逻辑，如给ID=2的这行数据的C列加1 |
| 写形式 | 固定的空间大小，循环写，满了就写入到磁盘中 | 追加写，不会覆盖，记录全量的备份数据   |


## 事务

### ACID：Atomicity原子性、Consistency一致性、Isolation隔离性、Durability持久性

### 脏读dirty read（读取了另一个未提交的事务中的数据）、不可重复读non-repeatable read（读取了前一事务提交的数据，多次读取结果不同）、幻读phantom read [举例](https://www.zhihu.com/question/47007926)

### 隔离级别：
#### read uncommitted读未提交：一个事务还没提交时，他做的变更就能被别的事务看到。
#### read committed读提交：一个事务提交后，它的变更才会被其他事务看到。
#### repeatable read可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的
#### serializable串行化：写会加锁，读会加锁。

例子：

![image](https://user-images.githubusercontent.com/32328586/117567002-7e242300-b0ec-11eb-9340-3b34995e633a.png)

- 若隔离级别是“读未提交”， 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。
- 若隔离级别是“读提交”，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。
- 若隔离级别是“可重复读”，则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。
- 若隔离级别是“串行化”，则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。

可重复读：数据库会通过MVCC机制创建一个视图，访问的时候以视图的逻辑结果为准，该级别的视图是在事务开始时创建的，整个事务都会使用这个视图。

Mysql的默认级别是RR，Oracle的级别是rc。

可以使用show variables like 'transaction_isolation';来查看当前的值。


### MVCC的实现：
在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。

![image](https://user-images.githubusercontent.com/32328586/117567765-3a331d00-b0f0-11eb-97a9-55dd7bb79aa1.png)

前值是 4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的 read-view。如图中看到的，在视图 A、B、C 里面，这一个记录的值分别是 1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于 read-view A，要得到 1，就必须将当前值依次执行图中所有的回滚操作得到。

回滚日志在不需要的时候才删除。系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除，即当系统里没有比这个回滚日志更早的 read-view 的时候。
因此不建议使用长事务，因为在事务结束前，会保留大量的回滚日志。

可以在information_schema库的innodb_trx表中查询长事务：
``` markdown
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60
```















